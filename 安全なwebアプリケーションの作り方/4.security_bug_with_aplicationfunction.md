# Webアプリケーションの機能別にみるセキュリティバグ

### 脆弱性はどこで発生するのか

* 脆弱性には処理に起因するものと出力に起因するものがある
  * 出力に起因する脆弱性例
    * HTMLの出力（クロスサイト・スクリプティング）
    * HTTPヘッダの出力（HTTPヘッダ・インジェクション）
    * SQL文の呼び出し（発行）（SQLインジェクション）
    * シェルコマンドの呼び出し（OSコマンド・インジェクション）
    * メールヘッダおよび本文の出力（メールヘッダ・インジェクション）

* 入力に起因する脆弱性はない
* 出力に起因する脆弱性には「インジェクション」という単語が付くものが多い

### インジェクション系脆弱性とは

## 入力処理とセキュリティ

### Webアプリケーションの入力では何をするか

入力処理

1. 文字エンコーディングの妥当性検証
2. 文字エンコーディングの変換（必要な場合のみ）
3. 入力値（パラメータ文字列）の妥当性検証

※1. は文字コードを使った攻撃手法への対応

### 文字エンコーディングの検証

* phpの場合

  ```c
  bool mb_check_encoding(string $var, string $encoding)
  ```

### 文字エンコーディングの変換


| 言語    | 自動変換             | スクリプトに記述    |
| ------- | -------------------- | ------------------- |
| PHP     | php.iniなど          | mb_convert_encoding |
| Perl    | ×                    | Encode::decode      |
| Java    | setCharacterEncoding | Stringクラス        |
| ASP.NET | Web.config           | ×                   |

### 文字エンコーディングのチェックと変換の例

```php
<?php
  $name = isset($_GET['name']) ? $_GET['name'] : '';
  // 文字エンコーディング（Shift_JIS）のチェック
  if (! mb_check_encoding($name, 'Shift_JIS')) {
    die('文字エンコーディングが不正です');
  }
 // 文字エンコーディングの変換（Shift_JIS→UTF-8）
  $name = mb_convert_encoding($name, 'UTF-8', 'Shift_JIS');
?>
<body>
名前は<?php echo htmlspecialchars($name, ENT_NOQUOTES, 'UTF-8'); ?>です
</body>
```

* mb_convert_encoding(<変換前文字列>, <変換後文字エンコーディング>, <変換前文字エンコーディング> )

* http://example.jp/42/42-001.php?name=%8ER%93cでアクセスした場合
  ![image-20220713082538126](img/image-20220713082538126.png)

* http://example.jp/42/42-001.php?name=%82%21でアクセスした場合
  ![image-20220713082651501](img/image-20220713082651501.png)

  * Shift_JISでは2バイト文字の2バイト目は0x40以上でなければならないため（%21が不正)

  ![image-20220713082858060](img/image-20220713082858060.png)

### 入力値の検証

#### 入力値検証の目的

* 入力値の間違いを早期に発見して再入力を促すことによりユーザビリティを向上
* データの不整合を防ぎシステムの信頼性向上

#### 入力値検証とセキュリティ

* 入力値検証がセキュリティの役に立つ
  * SQLインジェクション対策が漏れていたパラメータがあるが、英数字のみ許可していたので実害には至らない
  * PHPのバイナリセーフでない関数を使っているが、入力段階で制御文字をチェックしているので実害にならない

#### バイナリセーフという考え方とヌルバイト攻撃

バイナリセーフ：入力値がどんなバイト列であっても正しく扱えること。典型的には値ゼロのバイト(ヌルバイト、PHPでは\0と表記)が現れても正しく処理できることを指す。**C言語やwindowsのAPIでは、ヌルバイトを文字列の終端としてそれ以降を切り詰めてしまう**関数があり、このような関数をバイナリセーフではない関数という。

* 42-002.php

```php
<body>
<?php
  $p = $_GET['p'];
  if (ereg('^[0-9]+$', $p) === FALSE) {
    die('整数値を入力してください');
  }
  echo $p;
?>
</body>
```

* ​	http://example.jp/42/42-002.php?p=1234の場合

  ![image-20220713092715209](img/image-20220713092715209.png)

* http://example.jp/42/42-002.php?p=1%00%3Cscript%3Ealert(%27XSS%27)%3C/script%3E

![image-20220713092850030](img/image-20220713092850030.png)

→00%で1のみ出力された後後続のスクリプトが実行されてしまう。

バイナリセーフではない関数を使わずに開発することは、現実的には困難なため、アプリケーションの入り口でチェックし、ヌルバイトであればエラーにする対応が必要となる。

#### 入力値検証だけでは対策にならない

アプリケーションの仕様としてすべての文字を許容する場合は入力時点では何も防げないということになる

#### 制御文字のチェック

制御文字：ASCIIコード0x20未満及び0x7F(DELETE)の文字のこと

#### 文字数のチェック

すべての入力文字は最大文字数を仕様として定義すべき。SQLインジェクションの対策にもなる

#### 数値の最大値・最小値チェック

入力した数値に応じてメモリを確保するアプリケーションであれば、大きな数字を指定することでメモリ使用量が課題になる場合があり、DoS攻撃につながったりすることがある。

- 数字文字列としての文字種・文字数のチェック
- 文字列型から数値型への型変換
- 最小値、最大値の範囲にあることの確認



